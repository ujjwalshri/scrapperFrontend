import asyncHandler from "../utils/asyncHandler.js";
import ApiResponse from "../utils/apiResponse.js";
import { APIError } from "../utils/apiError.js";
import Menu from "../models/menuModel.js";
import User from "../models/userModel.js";
import { scrape } from "./scapperController.js";
import axios from "axios";
import { sendEmail } from "../services/mailService.js";
import { generatePDF } from "../services/generatePdf.js";

const getCompetitorDataWithScrape = async (itemName, latitude, longitude) => {
  const lat = latitude || "28.65420";
  const lng = longitude || "77.23730";

  const mockReq = {
    query: {
      item: itemName,
      lat: lat.toString(),
      long: lng.toString(),
    },
  };

  let responseData = null;
  const mockRes = {
    status: (statusCode) => ({
      json: (apiResponse) => {
        responseData = apiResponse;
      },
    }),
  };

  await scrape(mockReq, mockRes);

  if (responseData?.data?.data?.analytics) {
    return responseData.data.data.analytics;
  }
  return null;
};

const buildGeminiPrompt = (menu, user, itemAnalyses) => {
  let prompt = `You are a professional data analyst specializing in the Indian food service market. You are generating a **restaurant menu pricing analysis report** for a client based in **${
    menu.location?.name || "Kirti Nagar, Delhi"
  }**, using **data from competitors sourced via Swiggy**. The report should be structured and formatted to be **directly exportable as a polished PDF document**, with clear sections, tables, bolded highlights, and bullet points where necessary.
'Insufficient data is available to assess the value for money offered by Restroworks Cafe's menu. To conduct a
thorough value for money analysis, the following information is required:  ##DONOT USE THIS TEXT IN THE REPORT or any such text tht says data is insufficient##'
## ðŸ” Report Content Requirements:

1. **Title Page**  
   Include the following:
   - Report Title: **Menu Pricing Analysis Report**  
   - Subtitle: *Generated for: ${user.name} (${user.email})*  
   - Location: *${menu.location?.name || "Kirti Nagar, Delhi"}*  
   - Data Source: *Swiggy Competitor Data*  
   - Timestamp: *${new Date().toLocaleString("en-IN", {
     timeZone: "Asia/Kolkata",
   })}*

2. **I. Comparative Price Table**  
   Present a clean, well-aligned table comparing:
   - Item name  
   - ${menu.name}'s menu price (â‚¹)  
   - Average competitor price (â‚¹)  
   - Price difference (â‚¹)  
   - Percentage difference (%)  
   Use â‚¹ as the currency symbol and ensure price formatting is in Indian number style (e.g., â‚¹20,000.00).

3. **II. Outlier Detection**  
   Highlight which items are major pricing outliers with % difference over 200%. Use bullet points or emphasis formatting (bold or red text indicators) to denote urgency.

4. **III. Category Pricing Trends**  
   Group available items by category (e.g., Main Course, Beverage, Dessert) and mention if overpricing is consistent. If not enough data, mention limitations clearly.

5. **IV. Value for Money Analysis**  
   Explain if pricing is justified based on what's known (ingredients, portion size, presentation). If data is insufficient, state so clearly and suggest what's needed.

6. **V. Strategic Pricing Recommendations**  
   Offer **actionable suggestions**:
   - Suggested price range for each item  
   - Re-categorization notes if items are incorrectly labeled  
   - Call out any likely **data entry errors** (e.g., item listed at â‚¹20,000 could be due to currency mismatch or typo).

7. **VI. Suggestions for Further Research**  
   Recommend steps for deeper pricing strategy development, including:
   - Ingredient cost breakdown  
   - Portion size standardization  
   - Menu expansion for balanced analysis  
   - Broader competitor dataset  
   - Customer value perception survey

8. **VII. Final Conclusion**  
   Give a clear, data-driven summary:  
   - Is the current pricing viable?  
   - What are the key risks and opportunities?

## ðŸ–‹ Formatting Guidelines:

- Use proper **headings** (H1 to H4) for sections  
- Align tables neatly with currency formatting in â‚¹  
- Include bullet points and bold for key insights  
- Emphasize critical issues in **bold red** (e.g., gross overpricing)  
- Make the content **print-friendly**, with consistent spacing and alignment  
- Add a closing note or signature area with: *"Report generated by AI Assistant | ${new Date().toLocaleDateString(
    "en-IN",
    { timeZone: "Asia/Kolkata" }
  )}"*

## ðŸ—‚ Menu Details:
- Name: ${menu.name}
- Description: ${menu.description || "N/A"}
- Type: ${menu.type || "N/A"}
- Location: ${menu.location?.name || "Kirti Nagar, Delhi"}
- Coordinates: ${menu.location?.lat || "N/A"}, ${menu.location?.lon || "N/A"}

## ðŸ—‚ Menu Items (${menu.items ? menu.items.length : 0}):
${
  menu.items && menu.items.length > 0
    ? menu.items
        .map(
          (i) => `- ${i.name} (${i.category || "Uncategorized"}): â‚¹${i.price}`
        )
        .join("\n")
    : "None"
}`;

  if (itemAnalyses.length > 0) {
    prompt += `

## ðŸ—‚ Competitor Data Summary (from Swiggy):
${itemAnalyses
  .map(
    (itemData) => `  For Item: "${itemData.itemName}"
    - ${menu.name}'s Price: â‚¹${itemData.analysis.comparison.menuPrice.toFixed(
      2
    )}
    - Average Competitor Price: â‚¹${itemData.analysis.comparison.competitorAvgPrice.toFixed(
      2
    )}
    - Price Difference: â‚¹${itemData.analysis.comparison.priceDifference.toFixed(
      2
    )} (${itemData.analysis.comparison.percentageDifference}% ${
      itemData.analysis.comparison.isMoreExpensive ? "higher" : "lower"
    } than competitors)
    - Min Competitor Price: ${
      itemData.analysis.min
        ? `â‚¹${(itemData.analysis.min.price / 100).toFixed(2)} (Restaurant: ${
            itemData.analysis.min.name
          })`
        : "N/A"
    }
    - Max Competitor Price: ${
      itemData.analysis.max
        ? `â‚¹${(itemData.analysis.max.price / 100).toFixed(2)} (Restaurant: ${
            itemData.analysis.max.name
          })`
        : "N/A"
    }`
  )
  .join("\n\n")}`;
  } else {
    prompt += `

## ðŸ—‚ Competitor Data: 
No competitor data could be gathered for the items in this menu. Please focus the analysis on the target restaurant's own details and general market considerations for its type and location.`;
  }

  prompt +=
    "\n\nPlease provide your detailed analysis report following the structure and formatting guidelines above:";

  return prompt;
};

const analyzeMenu = asyncHandler(async (req, res) => {
  const { menuId } = req.params;

  if (!menuId) {
    throw new APIError(400, "Menu ID is required");
  }

  const menu = await Menu.findById(menuId).populate({
    path: "items",
    model: "MenuItem",
  });

  if (!menu) throw new APIError(404, "Menu not found");
  if (!menu.userId)
    throw new APIError(404, "Menu is not associated with a user");

  const user = await User.findById(menu.userId);
  if (!user) throw new APIError(404, "User associated with the menu not found");
  if (!user.email)
    throw new APIError(400, "User does not have an email address configured");

  const itemAnalyses = [];
  if (menu.items?.length > 0) {
    const analysisPromises = menu.items.map((item) =>
      getCompetitorDataWithScrape(
        item.name,
        menu.location?.lat,
        menu.location?.lon
      ).then((analysis) => ({
        itemName: item.name,
        itemData: item,
        analysis: analysis,
      }))
    );

    const results = await Promise.all(analysisPromises);
    const validResults = results.filter((result) => result.analysis !== null);

    validResults.forEach((result) => {
      try {
        const menuItemPrice = parseFloat(result.itemData.price) || 0;
        const avgPriceInPaise = result.analysis.avgPrice || 0;
        const competitorAvgPrice = avgPriceInPaise / 100;
        const priceDifference = menuItemPrice - competitorAvgPrice;

        let percentageDifference = "0.00";
        if (competitorAvgPrice > 0) {
          percentageDifference = (
            (priceDifference / competitorAvgPrice) *
            100
          ).toFixed(2);
        }

        result.analysis.comparison = {
          menuPrice: menuItemPrice,
          competitorAvgPrice: competitorAvgPrice,
          priceDifference: priceDifference,
          percentageDifference: percentageDifference,
          isMoreExpensive: priceDifference > 0,
          isLessExpensive: priceDifference < 0,
          isPriceMatch: Math.abs(priceDifference) < 0.01,
        };
      } catch (error) {
        console.error(
          `Error calculating price comparison for ${result.itemName}:`,
          error.message
        );
        result.analysis.comparison = {
          menuPrice: parseFloat(result.itemData.price) || 0,
          competitorAvgPrice: 0,
          priceDifference: 0,
          percentageDifference: "0.00",
          isMoreExpensive: false,
          isLessExpensive: false,
          isPriceMatch: false,
        };
      }
    });

    itemAnalyses.push(...validResults);
  }

  const apiKey = process.env.Gemini_Api;
  if (!apiKey) {
    throw new APIError(500, "Server configuration error: Missing API key");
  }

  const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;

  const prompt = buildGeminiPrompt(menu, user, itemAnalyses);

  let geminiResponseText = "Error: Could not get analysis from AI model.";
  try {
    const geminiResponse = await axios.post(geminiUrl, {
      contents: [{ parts: [{ text: prompt }] }],
      generationConfig: {
        temperature: 0.7,
      },
      safetySettings: [
        {
          category: "HARM_CATEGORY_HARASSMENT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE",
        },
        {
          category: "HARM_CATEGORY_HATE_SPEECH",
          threshold: "BLOCK_MEDIUM_AND_ABOVE",
        },
        {
          category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE",
        },
        {
          category: "HARM_CATEGORY_DANGEROUS_CONTENT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE",
        },
      ],
    });

    if (geminiResponse.data?.candidates?.[0]?.content?.parts?.[0]?.text) {
      geminiResponseText =
        geminiResponse.data.candidates[0].content.parts[0].text;
    }
  } catch (error) {
    geminiResponseText = `Error: Failed to get analysis from AI model. Details: ${error.message}`;
  }

  try {
    const pdfBuffer = await generatePDF(
      menu,
      user,
      geminiResponseText,
      itemAnalyses
    );
    await sendEmail(user, menu, pdfBuffer);

    return res
      .status(200)
      .json(
        new ApiResponse(
          200,
          { message: `Analysis complete. Report sent to ${user.email}` },
          "Analysis generated and email sent successfully"
        )
      );
  } catch (error) {
    throw new APIError(500, "Analysis generated, but failed to send email.", [
      error.message,
    ]);
  }
});

export { analyzeMenu };
